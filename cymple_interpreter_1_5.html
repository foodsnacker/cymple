<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cymple 1.5 - Online Interpreter</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .version {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        .editor-container {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 15px;
            margin-bottom: 20px;
        }

        #cymple-input {
            width: 100%;
            min-height: 450px;
            padding: 15px;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 0.9em;
            background: #1e1e1e;
            color: #d4d4d4;
            border: 2px solid #667eea;
            border-radius: 8px;
            resize: vertical;
            white-space: pre;
            tab-size: 4;
        }

        .syntax-panel {
            background: #f8f9fa;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px;
            max-height: 450px;
            overflow-y: auto;
        }

        .syntax-panel h3 {
            margin-top: 0;
            color: #667eea;
            font-size: 1em;
        }

        .syntax-panel p {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 10px;
        }

        .syntax-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .section-label {
            color: #667eea;
            font-weight: bold;
            font-size: 0.85em;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .snippet-btn {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px 12px;
            text-align: left;
            cursor: pointer;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .snippet-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .snippet-btn:active {
            transform: scale(0.98);
        }

        .run-btn {
            background: #667eea;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.2s;
        }

        .run-btn:hover {
            background: #5568d3;
        }

        .output {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border: 2px solid #667eea;
            border-radius: 8px;
        }

        .output strong {
            color: #667eea;
        }

        .output pre {
            margin-top: 10px;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .example-btn {
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 0.95em;
        }

        .example-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .warning {
            margin: 20px 0;
            padding: 15px;
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            color: #856404;
            border-radius: 4px;
        }

        .warning strong {
            display: block;
            margin-bottom: 5px;
        }

        .footer {
            background: #f8f9fa;
            padding: 20px;
            text-align: center;
            border-top: 1px solid #ddd;
        }

        .footer a {
            color: #667eea;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        @media (max-width: 900px) {
            .editor-container {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .examples-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }
        
        .clear-btn {
    background: #dc3545;
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 6px;
    font-size: 1em;
    cursor: pointer;
    transition: background 0.2s;
    margin-left: 10px;
}

.clear-btn:hover {
    background: #c82333;
}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”£ CYMPLE</h1>
            <p>Procedural Programming with Unicode Symbols</p>
            <span class="version">Version 1.5 â€¢ 2025-12-15 â€¢ Memory Safety</span>
        </div>

        <div class="content">
            <div class="section">
                <h2>Try Cymple Online</h2>
                <p>Edit the code and click "Run" to see the result. Click syntax snippets to insert them!</p>
                
                <div class="editor-container">
                    <div>
                        <textarea id="cymple-input">ğŸ’¬ "Hello, World!"</textarea>
                        <button class="run-btn" onclick="runCympleCode()">â–¶ï¸ Run Code</button>
						<button class="clear-btn" onclick="clearCymple()" style="background: #dc3545; margin-left: 10px;">ğŸ—‘ï¸ Clear</button>
                        <div id="cymple-output" class="output" style="display: none;">
                            <strong>Output:</strong>
                            <pre id="cymple-result"></pre>
                        </div>
                    </div>

                    <div class="syntax-panel">
                        <h3>ğŸ“– Syntax Quick Insert</h3>
                        <p>Click to insert at cursor:</p>
                        
                        <div class="syntax-buttons">
                            <div class="section-label">ğŸ’¬ Basic I/O</div>
                            <button onclick="insertSnippet('output')" class="snippet-btn">ğŸ’¬ Output</button>
                            <button onclick="insertSnippet('input')" class="snippet-btn">ğŸ”¤ğŸ”½ Input</button>
                            <button onclick="insertSnippet('comment')" class="snippet-btn">ğŸ“ Comment</button>
                            
                            <div class="section-label">ğŸ”¢ Variables</div>
                            <button onclick="insertSnippet('number')" class="snippet-btn">ğŸ”¢ Number</button>
                            <button onclick="insertSnippet('string')" class="snippet-btn">ğŸ”¤ String</button>
                            <button onclick="insertSnippet('assign')" class="snippet-btn">â† Assignment</button>
                            
                            <div class="section-label">âš™ï¸ Operations</div>
                            <button onclick="insertSnippet('math')" class="snippet-btn">+ Math (+ - * / %)</button>
                            <button onclick="insertSnippet('compare')" class="snippet-btn">== Compare (== != &lt; &gt;)</button>
                            <button onclick="insertSnippet('increment')" class="snippet-btn">++ Increment</button>
                            <button onclick="insertSnippet('interpolate')" class="snippet-btn">"ğŸ”¢" Interpolation</button>
                            
                            <div class="section-label">ğŸ”€ Control Flow</div>
                            <button onclick="insertSnippet('if')" class="snippet-btn">â“ If</button>
                            <button onclick="insertSnippet('ifelse')" class="snippet-btn">â“â¤µï¸ If-Else</button>
                            <button onclick="insertSnippet('while')" class="snippet-btn">ğŸ” While Loop</button>
                            
                            <div class="section-label">ğŸ§µ Functions</div>
                            <button onclick="insertSnippet('function')" class="snippet-btn">ğŸ§µ Function</button>
                            <button onclick="insertSnippet('funccall')" class="snippet-btn">ğŸ“ Call Function</button>
                            <button onclick="insertSnippet('main')" class="snippet-btn">ğŸ§µ main() <span style="color: #667eea;">1.5</span></button>
                            <button onclick="insertSnippet('return')" class="snippet-btn">â†© Return</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Example Programs</h2>
                <div class="examples-grid">
                    <button onclick="loadExample('hello')" class="example-btn">ğŸ“ Hello World</button>
                    <button onclick="loadExample('variables')" class="example-btn">ğŸ”¢ Variables & Math</button>
                    <button onclick="loadExample('input')" class="example-btn">ğŸ”¤ Interactive Input</button>
                    <button onclick="loadExample('ifelse')" class="example-btn">â“ If/Else</button>
                    <button onclick="loadExample('loop')" class="example-btn">ğŸ” While Loop</button>
                    <button onclick="loadExample('fibonacci')" class="example-btn">ğŸ§µ Fibonacci Function</button>
                    <button onclick="loadExample('factorial')" class="example-btn">âœ¨ Factorial</button>
                    <button onclick="loadExample('countdown')" class="example-btn">â±ï¸ Countdown</button>
                    <button onclick="loadExample('fizzbuzz')" class="example-btn">ğŸ¯ FizzBuzz</button>
                    <button onclick="loadExample('sum')" class="example-btn">â• Sum 1 to N</button>
                    <button onclick="loadExample('drawing')" class="example-btn">ğŸ¨ ASCII Art</button>
                </div>

                <div class="warning">
                    <strong>âš ï¸ Note:</strong> The following examples are theoretical. Quantum operations (Race and Collect) with full validation semantics are not implemented in this browser interpreter as of Cymple 1.5. They demonstrate syntax only. Full 1.5 features (handle validation, structured concurrency, bounds checking) require a native runtime.
                </div>

                <div class="examples-grid">
                    <button onclick="loadExample('race_simple')" class="example-btn">ğŸŒ€âš¡ Race Example (1.5)</button>
                    <button onclick="loadExample('race_timeout')" class="example-btn">â±ï¸ Race + Timeout (1.5)</button>
                    <button onclick="loadExample('collect_progress')" class="example-btn">â© Collect + Progress (1.5)</button>
                    <button onclick="loadExample('collect_cancel')" class="example-btn">ğŸ›‘ Early Cancel (1.5)</button>
                    <button onclick="loadExample('multi_search')" class="example-btn">ğŸ” Multi-Server Search (1.5)</button>
                    <button onclick="loadExample('memory_safe')" class="example-btn">ğŸ’¾ Safe Memory Block (1.5)</button>
                    <button onclick="loadExample('handle_validation')" class="example-btn">âœ… Handle Validation (1.5)</button>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>Cymple 1.5 - A research language exploring memory-safe procedural programming with Unicode symbols</p>
            <p><a href="https://github.com/foodsnacker/cymple" target="_blank">View on GitHub</a> | 
               <a href="https://cymple.org" target="_blank">Documentation</a></p>
        </div>
    </div>

<script>
// Cymple 1.5 Interpreter
// Note: This is a simplified interpreter for demonstration.
// Full 1.5 features (handle validation, structured concurrency, bounds checking)
// require a native runtime implementation.
class CympleInterpreter {
    constructor() {
        this.output = [];
        this.variables = {};
        this.functions = {};
        this.maxIterations = 10000;
        this.debug = false;
    }

    run(code) {
        this.output = [];
        this.variables = {};
        this.iterationCount = 0;
        
        const lines = code.split('\n');
        
        if (this.debug) {
            console.log('Lines:', lines.map((l, i) => `${i}: [${this.getIndent(l)}] "${l}"`));
        }
        
        this.executeBlock(lines, 0, lines.length);
        
        // NEW in 1.4: Auto-call main() if it exists
        if (this.functions['main']) {
            this.executeFunction('main', []);
        }

        return this.output.join('\n');
    }

    executeBlock(lines, startIdx, endIdx) {
        let i = startIdx;
        
        while (i < endIdx) {
            if (++this.iterationCount > this.maxIterations) {
                throw new Error('Maximum iteration limit reached (possible infinite loop)');
            }
            
            const line = lines[i];
            const trimmedLine = line.trim();
            const indent = this.getIndent(line);
            
            if (this.debug) {
                console.log(`Executing line ${i}: [indent=${indent}] "${trimmedLine}"`);
            }
            
            // Comments and empty lines
            if (trimmedLine.startsWith('ğŸ“') || !trimmedLine) {
                i++;
                continue;
            }
            
            // Clear Output: ğŸ—‘ï¸
            if (trimmedLine.startsWith('ğŸ—‘ï¸')) {
                this.output = [];
                if (this.debug) console.log('Output cleared');
                i++;
                continue;
            }
            
            // Refresh Display: ğŸ”„
            if (trimmedLine.startsWith('ğŸ”„')) {
                document.getElementById('cymple-output').style.display = 'block';
                document.getElementById('cymple-result').textContent = this.output.join('\n') || '(no output)';
                if (this.debug) console.log('Display refreshed');
                i++;
                continue;
            }
            
            // Function definition: ğŸ§µ name(params)
            if (trimmedLine.startsWith('ğŸ§µ')) {
                const funcMatch = trimmedLine.match(/ğŸ§µ\s*(\w+)\s*\(([^)]*)\)/);
                if (funcMatch) {
                    const [, name, params] = funcMatch;
                    const funcBody = [];
                    i++;
                    
                    while (i < endIdx && this.getIndent(lines[i]) > indent) {
                        funcBody.push(lines[i]);
                        i++;
                    }
                    
                    this.functions[name] = {
                        params: params.split(',').map(p => p.split(':')[0].trim()).filter(p => p),
                        body: funcBody
                    };
                    continue;
                }
            }
            
            // Variable: ğŸ”¢name â† value or ğŸ”¤name â† value
            if (trimmedLine.startsWith('ğŸ”¢') || trimmedLine.startsWith('ğŸ”¤')) {
                const match = trimmedLine.match(/[ğŸ”¢ğŸ”¤](\w+)\s*â†\s*(.+)/);
                if (match) {
                    const [, varName, valueExpr] = match;
                    const result = this.evaluateExpression(valueExpr.trim());
                    this.variables[varName] = result;
                    
                    if (this.debug) {
                        console.log(`Set variable ${varName} = ${result}`, this.variables);
                    }
                }
                i++;
                continue;
            }
            
            // While Loop: ğŸ” condition
            if (trimmedLine.startsWith('ğŸ”')) {
                let condition = trimmedLine.replace(/^ğŸ”\s*/, '').trim();
                
                const loopBody = [];
                const loopIndent = indent;
                i++;
                
                if (this.debug) console.log(`While loop: condition="${condition}", loopIndent=${loopIndent}`);
                
                while (i < endIdx) {
                    const lineIndent = this.getIndent(lines[i]);
                    if (lineIndent > loopIndent) {
                        loopBody.push(lines[i]);
                        i++;
                    } else {
                        break;
                    }
                }
                
                if (this.debug) console.log(`Loop body (${loopBody.length} lines):`, loopBody);
                
                let loopCount = 0;
                while (this.evaluateCondition(condition)) {
                    if (++this.iterationCount > this.maxIterations) {
                        throw new Error('Maximum iteration limit reached (possible infinite loop)');
                    }
                    
                    loopCount++;
                    if (this.debug) console.log(`Loop iteration ${loopCount}, variables:`, this.variables);
                    
                    const loopResult = this.executeBlock(loopBody, 0, loopBody.length);
                    if (loopResult !== null && loopResult !== undefined) {
                        return loopResult;
                    }
                }
                
                if (this.debug) console.log(`Loop finished after ${loopCount} iterations`);
                continue;
            }
            
            // If-Else: â“ condition
            if (trimmedLine.startsWith('â“')) {
                let condition = trimmedLine.replace(/^â“\s*/, '').trim();
                const ifIndent = indent;
                i++;
                
                if (this.debug) console.log(`If condition: "${condition}"`);
                
                const thenBlock = [];
                const elseBlock = [];
                
                while (i < endIdx && this.getIndent(lines[i]) > ifIndent && !lines[i].trim().startsWith('â¤µï¸') && !lines[i].trim().startsWith('âŒ')) {
                    thenBlock.push(lines[i]);
                    i++;
                }
                
                if (i < endIdx && (lines[i].trim().startsWith('â¤µï¸') || lines[i].trim().startsWith('âŒ'))) {
                    const elseIndent = this.getIndent(lines[i]);
                    i++;
                    while (i < endIdx && this.getIndent(lines[i]) > elseIndent) {
                        elseBlock.push(lines[i]);
                        i++;
                    }
                }
                
                if (this.evaluateCondition(condition)) {
                    if (thenBlock.length > 0) {
                        const result = this.executeBlock(thenBlock, 0, thenBlock.length);
                        if (result !== null && result !== undefined) {
                            return result;
                        }
                    }
                } else if (elseBlock.length > 0) {
                    const result = this.executeBlock(elseBlock, 0, elseBlock.length);
                    if (result !== null && result !== undefined) {
                        return result;
                    }
                }
                continue;
            }
            
            // Return: â†© expression
            if (trimmedLine.startsWith('â†©')) {
                let expr = trimmedLine.replace(/^â†©\s*/, '').trim();
                
                if (this.debug) console.log(`Return: "${expr}"`);
                
                const result = this.evaluateExpression(expr);
                
                if (this.debug) console.log(`Return value: ${result}`);
                
                return result;
            }
            
            // Function call: name(args)
            const funcCallMatch = trimmedLine.match(/^(\w+)\s*\(([^)]*)\)/);
            if (funcCallMatch && this.functions[funcCallMatch[1]]) {
                const [, name, argsStr] = funcCallMatch;
                const args = argsStr.split(',').map(a => this.evaluateExpression(a.trim()));
                this.executeFunction(name, args);
                i++;
                continue;
            }
            
            // Output: ğŸ’¬ expression
            if (trimmedLine.startsWith('ğŸ’¬')) {
                let expr = trimmedLine.replace(/^ğŸ’¬\s*/, '').trim();
                
                if (this.debug) console.log(`Output expression: "${expr}"`);
                
                const result = this.evaluateExpression(expr);
                const cleanResult = String(result).replace(/"/g, '');
                this.output.push(cleanResult);
                
                if (this.debug) console.log(`Output: "${cleanResult}"`);
                
                i++;
                continue;
            }
            
            i++;
        }
        
        return null;
    }

    executeFunction(name, args) {
        const func = this.functions[name];
        if (!func) return null;
        
        const savedVars = {...this.variables};
        
        func.params.forEach((param, idx) => {
            this.variables[param] = args[idx];
        });
        
        const result = this.executeBlock(func.body, 0, func.body.length);
        
        this.variables = savedVars;
        
        return result;
    }

    getIndent(line) {
        let count = 0;
        for (let char of line) {
            if (char === '\t') {
                count++;
            } else if (char === ' ') {
                count += 0.25;
            } else {
                break;
            }
        }
        return Math.floor(count);
    }

    evaluateCondition(expr) {
        expr = expr.trim();
        
        if (this.debug) console.log(`Evaluating condition: "${expr}"`);
        
        const operators = ['<=', '>=', '==', '!=', '<', '>'];
        
        for (const op of operators) {
            const idx = expr.indexOf(op);
            if (idx > 0) {
                const left = expr.substring(0, idx).trim();
                const right = expr.substring(idx + op.length).trim();
                
                const leftVal = this.evaluateExpression(left);
                const rightVal = this.evaluateExpression(right);
                
                let result;
                switch (op) {
                    case '<=': result = leftVal <= rightVal; break;
                    case '>=': result = leftVal >= rightVal; break;
                    case '<': result = leftVal < rightVal; break;
                    case '>': result = leftVal > rightVal; break;
                    case '==': result = leftVal == rightVal; break;
                    case '!=': result = leftVal != rightVal; break;
                }
                
                if (this.debug) console.log(`  ${leftVal} ${op} ${rightVal} = ${result}`);
                
                return result;
            }
        }
        
        const value = this.evaluateExpression(expr);
        return Boolean(value);
    }

evaluateExpression(expr) {
    expr = expr.trim();
    
    // Input function: ğŸ”¤ğŸ”½ "prompt"
    const inputMatch = expr.match(/ğŸ”¤ğŸ”½\s*"([^"]*)"/);
    if (inputMatch) {
        const promptText = inputMatch[1];
        const userInput = window.prompt(promptText);
        
        if (userInput === null) {
            throw new Error('User cancelled');
        }
        
        return userInput || '';
    }
    
    // Variable with emoji prefix: Check each emoji type individually
    let varName = null;
    let emojiPrefix = '';
    
    if (expr.startsWith('ğŸ”¢')) {
        emojiPrefix = 'ğŸ”¢';
        varName = expr.substring(2).trim();
    } else if (expr.startsWith('ğŸ”¤')) {
        emojiPrefix = 'ğŸ”¤';
        varName = expr.substring(2).trim();
    } else if (expr.startsWith('ğŸ“‹')) {
        emojiPrefix = 'ğŸ“‹';
        varName = expr.substring(2).trim();
    } else if (expr.startsWith('ğŸ”˜')) {
        emojiPrefix = 'ğŸ”˜';
        varName = expr.substring(2).trim();
    } else if (expr.startsWith('ğŸ–¼ï¸')) {
        emojiPrefix = 'ğŸ–¼ï¸';
        varName = expr.substring(3).trim(); // ğŸ–¼ï¸ is 3 chars!
    } else if (expr.startsWith('ğŸ“¦')) {
        emojiPrefix = 'ğŸ“¦';
        varName = expr.substring(2).trim();
    }
    
    // If we found an emoji prefix and it's just a variable (no operators)
    if (varName && varName.match(/^\w+$/) && !expr.includes('+') && !expr.includes('-') && !expr.includes('*') && !expr.includes('/') && !expr.includes('%')) {
        if (this.variables[varName] !== undefined) {
            return this.variables[varName];
        }
        throw new Error('Variable \'' + emojiPrefix + varName + '\' is not defined');
    }
    
    // Function call in expression
    const funcCallMatch = expr.match(/^(\w+)\s*\(([^)]*)\)/);
    if (funcCallMatch && this.functions[funcCallMatch[1]]) {
        const [, name, argsStr] = funcCallMatch;
        const args = argsStr ? argsStr.split(',').map(a => this.evaluateExpression(a.trim())) : [];
        return this.executeFunction(name, args);
    }
    
    // String literal WITH variable interpolation
    if (expr.startsWith('"') && expr.endsWith('"')) {
        let result = expr.slice(1, -1);
        
        // Replace all emoji-prefixed variables inside the string
        for (const [varName, value] of Object.entries(this.variables)) {
            result = result.replace(new RegExp('ğŸ”¢' + varName, 'g'), value);
            result = result.replace(new RegExp('ğŸ”¤' + varName, 'g'), value);
            result = result.replace(new RegExp('ğŸ“‹' + varName, 'g'), value);
            result = result.replace(new RegExp('ğŸ”˜' + varName, 'g'), value);
            result = result.replace(new RegExp('ğŸ–¼ï¸' + varName, 'g'), value);
            result = result.replace(new RegExp('ğŸ“¦' + varName, 'g'), value);
        }
        
        // Check fÃ¼r nicht-ersetzte Variablen
        const unreplacedNumber = result.match(/ğŸ”¢\w+/g);
        const unreplacedString = result.match(/ğŸ”¤\w+/g);
        const unreplacedList = result.match(/ğŸ“‹\w+/g);
        const unreplacedBool = result.match(/ğŸ”˜\w+/g);
        const unreplacedImage = result.match(/ğŸ–¼ï¸\w+/g);
        const unreplacedStruct = result.match(/ğŸ“¦\w+/g);
        
        const allUnreplaced = [
            ...(unreplacedNumber || []),
            ...(unreplacedString || []),
            ...(unreplacedList || []),
            ...(unreplacedBool || []),
            ...(unreplacedImage || []),
            ...(unreplacedStruct || [])
        ];
        
        if (allUnreplaced.length > 0) {
            throw new Error('Undefined variable(s) in string: ' + allUnreplaced.join(', '));
        }
        
        return result;
    }
    
    // String concatenation (still supported for compatibility)
    if (expr.includes('+') && expr.includes('"')) {
        const parts = [];
        let current = '';
        let inString = false;
        
        for (let i = 0; i < expr.length; i++) {
            const char = expr[i];
            
            if (char === '"') {
                inString = !inString;
                current += char;
            } else if (char === '+' && !inString) {
                if (current.trim()) {
                    parts.push(current.trim());
                }
                current = '';
            } else {
                current += char;
            }
        }
        
        if (current.trim()) {
            parts.push(current.trim());
        }
        
        const result = parts.map(p => {
            p = p.trim();
            if (p.startsWith('"') && p.endsWith('"')) {
                let str = p.slice(1, -1);
                for (const [varName, value] of Object.entries(this.variables)) {
                    str = str.replace(new RegExp('ğŸ”¢' + varName, 'g'), value);
                    str = str.replace(new RegExp('ğŸ”¤' + varName, 'g'), value);
                    str = str.replace(new RegExp('ğŸ“‹' + varName, 'g'), value);
                    str = str.replace(new RegExp('ğŸ”˜' + varName, 'g'), value);
                    str = str.replace(new RegExp('ğŸ–¼ï¸' + varName, 'g'), value);
                    str = str.replace(new RegExp('ğŸ“¦' + varName, 'g'), value);
                }
                return str;
            }
            
            // Check for emoji-prefixed variable
            if (p.startsWith('ğŸ”¢')) {
                const vName = p.substring(2);
                if (this.variables[vName] !== undefined) {
                    return String(this.variables[vName]);
                }
                throw new Error('Variable \'' + p + '\' is not defined');
            }
            if (p.startsWith('ğŸ”¤')) {
                const vName = p.substring(2);
                if (this.variables[vName] !== undefined) {
                    return String(this.variables[vName]);
                }
                throw new Error('Variable \'' + p + '\' is not defined');
            }
            if (p.startsWith('ğŸ“‹')) {
                const vName = p.substring(2);
                if (this.variables[vName] !== undefined) {
                    return String(this.variables[vName]);
                }
                throw new Error('Variable \'' + p + '\' is not defined');
            }
            if (p.startsWith('ğŸ”˜')) {
                const vName = p.substring(2);
                if (this.variables[vName] !== undefined) {
                    return String(this.variables[vName]);
                }
                throw new Error('Variable \'' + p + '\' is not defined');
            }
            if (p.startsWith('ğŸ–¼ï¸')) {
                const vName = p.substring(3); // ğŸ–¼ï¸ is 3 chars
                if (this.variables[vName] !== undefined) {
                    return String(this.variables[vName]);
                }
                throw new Error('Variable \'' + p + '\' is not defined');
            }
            if (p.startsWith('ğŸ“¦')) {
                const vName = p.substring(2);
                if (this.variables[vName] !== undefined) {
                    return String(this.variables[vName]);
                }
                throw new Error('Variable \'' + p + '\' is not defined');
            }
            
            if (this.variables[p] !== undefined) {
                return String(this.variables[p]);
            }
            return String(this.evaluateMath(p));
        }).join('');
        
        return result;
    }
    
    // Math operations - only if contains math operators
    if (expr.match(/[\+\-\*\/\%]/)) {
        return this.evaluateMath(expr);
    }
    
    // Variable without prefix
    if (this.variables[expr] !== undefined) {
        return this.variables[expr];
    }
    
    // Number
    const num = parseFloat(expr);
    if (!isNaN(num)) {
        return num;
    }
    
    return expr;
}

    evaluateMath(expr) {
        let evalExpr = expr;
        
        // Replace emoji-prefixed variables first
        for (const [varName, value] of Object.entries(this.variables)) {
            evalExpr = evalExpr.replace(new RegExp('ğŸ”¢' + varName + '\\b', 'g'), value);
            evalExpr = evalExpr.replace(new RegExp('ğŸ”¤' + varName + '\\b', 'g'), value);
            evalExpr = evalExpr.replace(new RegExp('ğŸ“‹' + varName + '\\b', 'g'), value);
            evalExpr = evalExpr.replace(new RegExp('ğŸ”˜' + varName + '\\b', 'g'), value);
            evalExpr = evalExpr.replace(new RegExp('ğŸ–¼ï¸' + varName + '\\b', 'g'), value);
            evalExpr = evalExpr.replace(new RegExp('ğŸ“¦' + varName + '\\b', 'g'), value);
            evalExpr = evalExpr.replace(new RegExp('\\b' + varName + '\\b', 'g'), value);
        }
        
        // Check ob noch Emoji-Variablen Ã¼brig sind (= nicht definiert!)
        const unresolvedVars = evalExpr.match(/[ğŸ”¢ğŸ”¤ğŸ“‹ğŸ”˜ğŸ–¼ï¸ğŸ“¦]\w+/g);
        if (unresolvedVars) {
            throw new Error('Undefined variable(s): ' + unresolvedVars.join(', '));
        }
        
        try {
            const result = eval(evalExpr);
            return result;
        } catch (e) {
            console.error('Math eval error:', e, 'Expression:', evalExpr);
            throw new Error('Invalid expression: ' + expr);
        }
    }
}

// Snippet insertion function
function insertSnippet(type) {
    const textarea = document.getElementById('cymple-input');
    const snippets = {
        'output': 'ğŸ’¬ "Hello, World!"',
        'input': 'ğŸ”¤name â† ğŸ”¤ğŸ”½ "Enter your name"\nğŸ’¬ "Hello, ğŸ”¤name!"',
        'comment': 'ğŸ“ This is a comment',
        'number': 'ğŸ”¢count â† 42',
        'string': 'ğŸ”¤name â† "Alice"',
        'assign': 'ğŸ”¢x â† 42',
        'math': 'ğŸ”¢result â† ğŸ”¢a + ğŸ”¢b',
        'compare': 'â“ ğŸ”¢x == ğŸ”¢y',
        'increment': 'ğŸ”¢i â† ğŸ”¢i + 1',
        'interpolate': 'ğŸ’¬ "Value: ğŸ”¢x"',
        'if': 'â“ ğŸ”¢x > 0\n\tğŸ’¬ "Positive"',
        'ifelse': 'â“ ğŸ”¢x > 0\n\tğŸ’¬ "Positive"\nâ¤µï¸\n\tğŸ’¬ "Not positive"',
        'while': 'ğŸ”¢i â† 1\nğŸ” ğŸ”¢i <= 5\n\tğŸ’¬ "Count: ğŸ”¢i"\n\tğŸ”¢i â† ğŸ”¢i + 1',
        'function': 'ğŸ§µ greet(name: ğŸ”¤)\n\tğŸ’¬ "Hello, ğŸ”¤name!"',
        'funccall': 'ğŸ”¢result â† myFunction(arg1, arg2)',
        'main': 'ğŸ§µ main()\n\tğŸ’¬ "Program starts here"',
        'return': 'â†© result'
    };
    
    const snippet = snippets[type] || '';
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = textarea.value;
    
    const before = text.substring(0, start);
    const after = text.substring(end);
    
    const prefix = (start > 0 && before[before.length - 1] !== '\n') ? '\n' : '';
    const suffix = '\n';
    
    textarea.value = before + prefix + snippet + suffix + after;
    
    const newPos = start + prefix.length + snippet.length + suffix.length;
    textarea.selectionStart = newPos;
    textarea.selectionEnd = newPos;
    textarea.focus();
}

function clearCymple() {
    document.getElementById('cymple-input').value = 'ğŸ’¬ "Hello, World!"';
    document.getElementById('cymple-output').style.display = 'none';
    document.getElementById('cymple-result').textContent = '';
    document.getElementById('cymple-input').focus();
}

function runCympleCode() {
    const code = document.getElementById('cymple-input').value;
    
    try {
        const interpreter = new CympleInterpreter();
        const result = interpreter.run(code);
        
        document.getElementById('cymple-output').style.display = 'block';
        document.getElementById('cymple-result').textContent = result || '(no output)';
    } catch (error) {
        document.getElementById('cymple-output').style.display = 'block';
        document.getElementById('cymple-result').textContent = 'âŒ Error: ' + error.message;
        console.error('Cymple Error:', error);
    }
}

function loadExample(type) {
    const examples = {
        'hello': 'ğŸ’¬ "Hello, World!"',
        
        'variables': `ğŸ“ Simple math (v1.4 with string interpolation)
ğŸ”¢x â† 5
ğŸ”¢y â† 10
ğŸ”¢result â† ğŸ”¢x + ğŸ”¢y
ğŸ’¬ "x + y = ğŸ”¢result"`,
        
        'input': `ğŸ“ Interactive greeting (v1.4 style)
ğŸ”¤name â† ğŸ”¤ğŸ”½ "Enter your name"
ğŸ’¬ "Hello, ğŸ”¤name!"`,
        
        'ifelse': `ğŸ“ Check if number is positive (v1.4)
ğŸ”¢num â† 7
â“ ğŸ”¢num > 0
\tğŸ’¬ "Number is positive"
â¤µï¸
\tğŸ’¬ "Number is not positive"`,
        
        'loop': `ğŸ“ Count from 1 to 5 (v1.4)
ğŸ”¢i â† 1
ğŸ” ğŸ”¢i <= 5
\tğŸ’¬ "Count: ğŸ”¢i"
\tğŸ”¢i â† ğŸ”¢i + 1`,
        
        'fibonacci': `ğŸ“ Fibonacci function (v1.4)
ğŸ§µ fib(n: ğŸ”¢) -> ğŸ”¢
\tâ“ n <= 1
\t\tâ†© n
\tğŸ”¢a â† fib(n - 1)
\tğŸ”¢b â† fib(n - 2)
\tâ†© ğŸ”¢a + ğŸ”¢b

ğŸ”¢result â† fib(8)
ğŸ’¬ "Fibonacci(8) = ğŸ”¢result"`,
        
        'factorial': `ğŸ“ Calculate factorial (v1.4)
ğŸ§µ factorial(n: ğŸ”¢) -> ğŸ”¢
\tâ“ n <= 1
\t\tâ†© 1
\tğŸ”¢prev â† factorial(n - 1)
\tâ†© n * ğŸ”¢prev

ğŸ”¢result â† factorial(6)
ğŸ’¬ "6! = ğŸ”¢result"`,
        
        'countdown': `ğŸ“ Countdown from 10 (v1.4)
ğŸ”¢count â† 10
ğŸ” ğŸ”¢count > 0
\tğŸ’¬ "Countdown: ğŸ”¢count"
\tğŸ”¢count â† ğŸ”¢count - 1
ğŸ’¬ "Liftoff! ğŸš€"`,
        
        'fizzbuzz': `ğŸ“ FizzBuzz from 1 to 15 (v1.4)
ğŸ”¢i â† 1
ğŸ” ğŸ”¢i <= 15
\tğŸ”¢div3 â† ğŸ”¢i % 3
\tğŸ”¢div5 â† ğŸ”¢i % 5
\tâ“ ğŸ”¢div3 == 0
\t\tâ“ ğŸ”¢div5 == 0
\t\t\tğŸ’¬ "FizzBuzz"
\t\tâ¤µï¸
\t\t\tğŸ’¬ "Fizz"
\tâ¤µï¸
\t\tâ“ ğŸ”¢div5 == 0
\t\t\tğŸ’¬ "Buzz"
\t\tâ¤µï¸
\t\t\tğŸ’¬ "ğŸ”¢i"
\tğŸ”¢i â† ğŸ”¢i + 1`,
        
        'sum': `ğŸ“ Sum of numbers from 1 to N (v1.4)
ğŸ”¢n â† 10
ğŸ”¢sum â† 0
ğŸ”¢i â† 1
ğŸ” ğŸ”¢i <= ğŸ”¢n
\tğŸ”¢sum â† ğŸ”¢sum + ğŸ”¢i
\tğŸ”¢i â† ğŸ”¢i + 1
ğŸ’¬ "Sum 1 to ğŸ”¢n = ğŸ”¢sum"`,

        'race_simple': `ğŸ“ Quantum Race - Simple Example (v1.5)
ğŸ“ NOTE: This shows SYNTAX only
ğŸ“ Interpreter doesn't execute parallel tasks

ğŸ’¬ "=== Cymple 1.5: Race Operation ==="
ğŸ’¬ " "
ğŸ’¬ "Syntax:"
ğŸ’¬ "ğŸŒ€âš¡ ğŸ”¤result â† [task1(), task2(), task3()]"
ğŸ’¬ "    â±ï¸ 5s    ğŸ“ SHOULD have timeout (1.5)"
ğŸ’¬ "        â†© fallback()"
ğŸ’¬ "    âœ… ğŸ”¤winner"
ğŸ’¬ "        ğŸ’¬ \\"Winner: ğŸ”¤winner\\""
ğŸ’¬ "    ğŸ“ Tasks auto-cleaned up here!"
ğŸ’¬ " "
ğŸ’¬ "Starts 3 tasks in parallel"
ğŸ’¬ "Returns first result"
ğŸ’¬ "Cancels other tasks with ğŸ›‘"
ğŸ’¬ " "
ğŸ’¬ "NEW in 1.5:"
ğŸ’¬ "â€¢ Structured concurrency"
ğŸ’¬ "â€¢ Tasks guaranteed cleaned"
ğŸ’¬ "â€¢ Timeouts RECOMMENDED"
ğŸ’¬ " "
ğŸ’¬ "Use case: Multi-region API calls"`,

        'race_timeout': `ğŸ“ Race with Timeout (v1.5)
ğŸ“ NOTE: This shows SYNTAX only

ğŸ’¬ "=== Race + Timeout (v1.5) ==="
ğŸ’¬ " "
ğŸ’¬ "Syntax:"
ğŸ’¬ "ğŸŒ€âš¡ ğŸ”¤result â† [fetch_eu(), fetch_us()]"
ğŸ’¬ "    â±ï¸ 3s    ğŸ“ REQUIRED for safety"
ğŸ’¬ "        ğŸ’¬ \\"Timeout!\\""
ğŸ’¬ "        â†© cached_value()"
ğŸ’¬ "    âœ… ğŸ”¤winner"
ğŸ’¬ "        â†© ğŸ”¤winner"
ğŸ’¬ "    ğŸ“ Tasks auto-cancelled here"
ğŸ’¬ " "
ğŸ’¬ "Time units (1.4+):"
ğŸ’¬ "â€¢ 3s, 500ms, 2m, 1h"
ğŸ’¬ "â€¢ Variables: â±ï¸ ğŸ”¢timeout"
ğŸ’¬ " "
ğŸ’¬ "NEW in 1.5:"
ğŸ’¬ "â€¢ Timeouts STRONGLY RECOMMENDED"
ğŸ’¬ "â€¢ Prevents indefinite blocking"
ğŸ’¬ "â€¢ Structured cleanup guaranteed"`,

        'collect_progress': `ğŸ“ Collect with Progress (v1.5)
ğŸ“ NOTE: This shows SYNTAX only

ğŸ’¬ "=== Collect + Progress (v1.5) ==="
ğŸ’¬ " "
ğŸ’¬ "Syntax:"
ğŸ’¬ "ğŸŒ€ğŸ“¦ ğŸ“‹results â† [task1(), task2(), ... task100()]"
ğŸ’¬ "    â±ï¸ 30s    ğŸ“ Timeout recommended"
ğŸ’¬ "        â†© ğŸ“‹results"
ğŸ’¬ "    â© ğŸ“‹partial every 10    ğŸ“ Efficient!"
ğŸ’¬ "        ğŸ’¬ \\"Progress: ğŸ“‹partial.length\\""
ğŸ’¬ "    âœ… ğŸ“‹all"
ğŸ’¬ "        â†© filter_ok(ğŸ“‹all)"
ğŸ’¬ "    ğŸ“ Tasks auto-cleaned here"
ğŸ’¬ " "
ğŸ’¬ "Progress frequency (1.4+):"
ğŸ’¬ "â€¢ every 10: Only 10 events"
ğŸ’¬ "â€¢ Without: 100 events (slow!)"
ğŸ’¬ " "
ğŸ’¬ "NEW in 1.5:"
ğŸ’¬ "â€¢ Structured concurrency"
ğŸ’¬ "â€¢ Runtime cap (default 1000)"
ğŸ’¬ "â€¢ Batch large task lists"
ğŸ’¬ " "
ğŸ’¬ "Use case:"
ğŸ’¬ "â€¢ Batch processing"
ğŸ’¬ "â€¢ Parallel downloads"`,

        'collect_cancel': `ğŸ“ Early Cancellation with ğŸ›‘ (v1.5)
ğŸ“ NOTE: This shows SYNTAX only

ğŸ’¬ "=== Early Cancel (v1.5) ==="
ğŸ’¬ " "
ğŸ’¬ "Syntax:"
ğŸ’¬ "ğŸŒ€ğŸ“¦ ğŸ“‹results â† [search_db1(), ... search_db10()]"
ğŸ’¬ "    â±ï¸ 30s    ğŸ“ Timeout safety"
ğŸ’¬ "        â†© ğŸ“‹results"
ğŸ’¬ "    â© ğŸ“‹partial every 5"
ğŸ’¬ "        ğŸ’¬ \\"Found: ğŸ“‹partial.length\\""
ğŸ’¬ "        â“ ğŸ“‹partial.length >= 20"
ğŸ’¬ "            ğŸ’¬ \\"Enough results!\\""
ğŸ’¬ "            ğŸ›‘    ğŸ“ Stop remaining tasks"
ğŸ’¬ "            â†© ğŸ“‹partial"
ğŸ’¬ "    âœ… ğŸ“‹all"
ğŸ’¬ "        â†© ğŸ“‹all"
ğŸ’¬ "    ğŸ“ Tasks auto-cleaned here"
ğŸ’¬ " "
ğŸ’¬ "Benefits (1.4+):"
ğŸ’¬ "â€¢ Stop when you have enough"
ğŸ’¬ "â€¢ Save resources"
ğŸ’¬ "â€¢ 70% faster when stopping early"
ğŸ’¬ " "
ğŸ’¬ "NEW in 1.5:"
ğŸ’¬ "â€¢ Structured cleanup guaranteed"
ğŸ’¬ "â€¢ Runtime cap prevents spawn storms"`,

        'multi_search': `ğŸ“ Multi-Server Search (v1.5)
ğŸ“ Now with structured concurrency

ğŸ’¬ "=== Multi-Server Search (v1.5) ==="
ğŸ’¬ " "
ğŸ’¬ "Problem:"
ğŸ’¬ "â€¢ 3 search APIs (EU, US, Asia)"
ğŸ’¬ "â€¢ Don't know which is fastest"
ğŸ’¬ "â€¢ Need result ASAP"
ğŸ’¬ " "
ğŸ’¬ "Cymple 1.5 Solution:"
ğŸ’¬ " "
ğŸ’¬ "ğŸ§µ search_fastest(ğŸ”¤query) -> ğŸ”¤"
ğŸ’¬ "    ğŸŒ€âš¡ ğŸ”¤result â† ["
ğŸ’¬ "        search_eu(ğŸ”¤query),"
ğŸ’¬ "        search_us(ğŸ”¤query),"
ğŸ’¬ "        search_asia(ğŸ”¤query)"
ğŸ’¬ "    ]"
ğŸ’¬ "        â±ï¸ 3s"
ğŸ’¬ "            â†© cached_search(ğŸ”¤query)"
ğŸ’¬ "        âœ… ğŸ”¤winner"
ğŸ’¬ "            â†© ğŸ”¤winner"
ğŸ’¬ "    ğŸ“ Tasks auto-cancelled/cleaned here!"
ğŸ’¬ " "
ğŸ’¬ "NEW in 1.5:"
ğŸ’¬ "â€¢ Structured concurrency"
ğŸ’¬ "â€¢ Tasks guaranteed cleaned up"
ğŸ’¬ "â€¢ No resource leaks"
ğŸ’¬ "â€¢ 3s timeout (SHOULD have)"
ğŸ’¬ " "
ğŸ’¬ "vs JavaScript: 50+ lines"
ğŸ’¬ "vs Go: 65+ lines"`,

        'memory_safe': `ğŸ“ Safe Memory Block (v1.5)
ğŸ“ This shows memory safety features

ğŸ’¬ "=== Safe Memory Blocks (v1.5) ==="
ğŸ’¬ " "
ğŸ’¬ "NEW in 1.5: Validated Handles"
ğŸ’¬ " "
ğŸ’¬ "Syntax:"
ğŸ’¬ "ğŸ’¾buffer â† allocate(100)"
ğŸ’¬ " "
ğŸ’¬ "ğŸ”— buffer -> mut B"
ğŸ’¬ "    B[0] â† 42     ğŸ“ OK - validated"
ğŸ’¬ "    B[99] â† 99    ğŸ“ OK - within bounds"
ğŸ’¬ "    B[150] â† 5    ğŸ“ ERROR: Bounds check!"
ğŸ’¬ " "
ğŸ’¬ "Features:"
ğŸ’¬ "â€¢ Handle validation on every use"
ğŸ’¬ "â€¢ Generation counter checks"
ğŸ’¬ "â€¢ Bounds checking (REQUIRED)"
ğŸ’¬ "â€¢ Array-like indexing"
ğŸ’¬ "â€¢ No pointer arithmetic"
ğŸ’¬ " "
ğŸ’¬ "Benefits:"
ğŸ’¬ "â€¢ No buffer overflows"
ğŸ’¬ "â€¢ Safe by default"
ğŸ’¬ "â€¢ Catches errors immediately"
ğŸ’¬ "â€¢ No undefined behavior"`,

        'handle_validation': `ğŸ“ Handle Validation (v1.5)
ğŸ“ Use-after-free detection

ğŸ’¬ "=== Handle Validation (v1.5) ==="
ğŸ’¬ " "
ğŸ’¬ "Syntax:"
ğŸ’¬ "ğŸ’¾block â† allocate(100)"
ğŸ’¬ "ğŸ”— block -> B"
ğŸ’¬ "    B[0] â† 42    ğŸ“ OK - valid handle"
ğŸ’¬ " "
ğŸ’¬ "release(block)   ğŸ“ Generation increments"
ğŸ’¬ " "
ğŸ’¬ "ğŸ“‹val â† block[0]  ğŸ“ ERROR: Stale handle!"
ğŸ’¬ " "
ğŸ’¬ "Handle Structure (internal):"
ğŸ’¬ "â€¢ slot/index"
ğŸ’¬ "â€¢ generation counter"
ğŸ’¬ "â€¢ kind/type tag"
ğŸ’¬ " "
ğŸ’¬ "Validation (MUST):"
ğŸ’¬ "1. Slot in range?"
ğŸ’¬ "2. Slot occupied?"
ğŸ’¬ "3. Generation matches?"
ğŸ’¬ "4. Kind matches?"
ğŸ’¬ " "
ğŸ’¬ "On failure: Runtime error/panic"
ğŸ’¬ " "
ğŸ’¬ "Result: Use-after-free IMPOSSIBLE"`,

        'drawing': `ğŸ“ Simple ASCII Art
ğŸ’¬ "   /\\\\\\\\"
ğŸ’¬ "  /  \\\\\\\\"
ğŸ’¬ " /    \\\\\\\\"
ğŸ’¬ "/______\\\\\\\\"
ğŸ’¬ "|      |"
ğŸ’¬ "|  []  |"
ğŸ’¬ "|______|"`
    };
    
    document.getElementById('cymple-input').value = examples[type] || examples['hello'];
    document.getElementById('cymple-output').style.display = 'none';
}
</script>
</body>
</html>

