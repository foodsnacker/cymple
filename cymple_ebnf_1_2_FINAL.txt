# CYMPLE 1.2 - Extended Backus-Naur Form (EBNF) Grammar

## Notation

```
::=     definition
|       alternation
()      grouping
[]      optional (zero or one)
{}      repetition (zero or more)
+       repetition (one or more)
" "     terminal symbol
/* */   comment
```

---

## Lexical Elements

```ebnf
(* Basic tokens *)
NEWLINE       ::= "\n"
TAB           ::= "\t"
INDENT        ::= TAB+
OUTDENT       ::= /* decrease in indentation level */

(* Whitespace and comments *)
COMMENT       ::= "ğŸ“" { any_character_except_newline }
WHITESPACE    ::= " " | "\t"

(* Literals *)
NUMBER        ::= ["-"] digit+ ["." digit+] [("e"|"E") ["+"|"-"] digit+]
STRING        ::= '"' { string_char | escape_sequence } '"'
BOOL_TRUE     ::= "âœ…"
BOOL_FALSE    ::= "âœ—"

escape_sequence ::= "\\" ( '"' | "\\" | "n" | "t" | "u{" hex_digit+ "}" )
digit          ::= "0".."9"
hex_digit      ::= "0".."9" | "a".."f" | "A".."F"

(* Identifiers *)
IDENTIFIER    ::= (letter | emoji) { letter | digit | emoji | "_" }
                /* UAX-31 compliant, allows emoji */

letter        ::= /* any Unicode letter per UAX-31 */
emoji         ::= /* any Unicode emoji character */

(* Symbols *)
ASSIGN        ::= "â†"
RETURN        ::= "â†©"
IF            ::= "â“"
LOOP          ::= "ğŸ”"
CONSTANT      ::= "ğŸ“˜"
BORROW        ::= "ğŸ”—"
BORROW_MUT    ::= "mut"
FUNCTION      ::= "ğŸ§µ"
MATCH         ::= "ğŸ”€"
MATCH_ARM     ::= "âœ"
WILDCARD      ::= "_"
GUARD         ::= "â“"
RANGE_INCL    ::= ".."
RANGE_EXCL    ::= "..<"
STEP          ::= "â©"
NULL          ::= "null"
NULL_HANDLE   ::= "null_handle"
STRUCT        ::= "ğŸ§±"
CHANNEL       ::= "ğŸ“¡"
CREATE_CHAN   ::= "ğŸ›°ï¸"
SEND          ::= "ğŸš€"
RECEIVE       ::= "ğŸ¯"
CANCEL        ::= "ğŸ›‘"
QUANTUM_RACE  ::= "ğŸŒ€âš¡"
QUANTUM_COLL  ::= "ğŸŒ€ğŸ“¦"
SELECT        ::= "select"
SPAWN         ::= "spawn"
TIMER_ONCE    ::= "â±ï¸â–¶"
TIMER_REPEAT  ::= "â±ï¸ğŸ”"
MODULE        ::= "ğŸ§©"
PLUGIN        ::= "ğŸ› ï¸"
CALL_OP       ::= "â–¶"
FFI           ::= "ğŸ”—"
PRINT         ::= "ğŸ’¬"
COLOR         ::= "ğŸ¨"
FREE          ::= "ğŸ—‘ï¸"
GURU          ::= "ğŸ§˜"
ERROR         ::= "âŒ"
WARNING       ::= "âš ï¸"
FATAL         ::= "ğŸ’€"
IN            ::= "in"
AS            ::= "as"
CONTINUE      ::= "continue"
BREAK         ::= "break"

(* Type symbols *)
TYPE_NUMBER   ::= "ğŸ”¢"
TYPE_STRING   ::= "ğŸ”¤"
TYPE_LIST     ::= "ğŸ“‹"
TYPE_MAP      ::= "ğŸ—ºï¸"
TYPE_BYTEARRAY::= "ğŸ”£"

(* Event symbols *)
EVENT_SUCCESS ::= "âœ…"
EVENT_ERROR   ::= "âŒ"
EVENT_PROGRESS::= "â©"
EVENT_STOPPED ::= "â¹ï¸"
EVENT_REPEAT  ::= "ğŸ”"

(* Handle prefixes - examples *)
HANDLE_AUDIO  ::= "ğŸµ"
HANDLE_IMAGE  ::= "ğŸ–¼ï¸"
HANDLE_FILE   ::= "ğŸ’¾"
/* etc. - any emoji can serve as handle prefix */
```

---

## Program Structure

```ebnf
program ::= { statement }

statement ::= simple_statement NEWLINE
           | compound_statement

simple_statement ::= assignment
                  | return_stmt
                  | print_stmt
                  | function_call
                  | send_stmt
                  | receive_stmt
                  | cancel_stmt
                  | free_stmt
                  | color_stmt
                  | continue_stmt
                  | break_stmt
                  | error_throw
                  | COMMENT

compound_statement ::= if_statement
                    | loop_statement
                    | function_def
                    | struct_def
                    | match_statement
                    | borrow_block
                    | spawn_block
                    | quantum_block
                    | select_block
                    | timer_block
                    | guru_block
                    | module_import
                    | plugin_import
                    | ffi_block
                    | comment_block
```

---

## Expressions

```ebnf
expression ::= logical_or

logical_or ::= logical_and { "||" logical_and }

logical_and ::= equality { "&&" equality }

equality ::= comparison { ("=" | "!=") comparison }

comparison ::= range { ("<" | ">" | "<=" | ">=") range }

range ::= additive [ (RANGE_INCL | RANGE_EXCL) additive [ STEP additive ] ]

additive ::= multiplicative { ("+" | "-") multiplicative }

multiplicative ::= unary { ("*" | "/" | "%") unary }

unary ::= ("!" | "-") unary
       | postfix

postfix ::= primary { postfix_op }

postfix_op ::= "." IDENTIFIER              /* field access */
            | "[" expression "]"           /* index access */
            | "(" [ argument_list ] ")"    /* function call */

primary ::= NUMBER
         | STRING
         | BOOL_TRUE
         | BOOL_FALSE
         | NULL
         | NULL_HANDLE
         | IDENTIFIER
         | handle
         | list_literal
         | map_literal
         | bytearray_literal
         | struct_literal
         | "(" expression ")"

handle ::= emoji IDENTIFIER  /* e.g., ğŸµsnd, ğŸ’¾file */

list_literal ::= TYPE_LIST "[" [ expression_list ] "]"
              | "[" range "]"  /* range to list conversion */

map_literal ::= TYPE_MAP "{" [ map_entries ] "}"

map_entries ::= map_entry { "," map_entry }

map_entry ::= STRING ":" expression

bytearray_literal ::= TYPE_BYTEARRAY "[" [ expression_list ] "]"

struct_literal ::= IDENTIFIER "(" [ named_arguments ] ")"

expression_list ::= expression { "," expression }

argument_list ::= expression { "," expression }

named_arguments ::= named_arg { "," named_arg }

named_arg ::= IDENTIFIER ":" expression
```

---

## Statements

### Assignment

```ebnf
assignment ::= [CONSTANT] type_annotation IDENTIFIER ASSIGN expression
            | IDENTIFIER ASSIGN expression

type_annotation ::= TYPE_NUMBER
                 | TYPE_STRING
                 | TYPE_LIST
                 | TYPE_MAP
                 | TYPE_BYTEARRAY
                 | STRUCT
                 | CHANNEL
```

### Return

```ebnf
return_stmt ::= RETURN [expression]
```

### Print

```ebnf
print_stmt ::= PRINT expression
```

### Control Flow

```ebnf
continue_stmt ::= CONTINUE

break_stmt ::= BREAK
```

---

## Compound Statements

### If Statement

```ebnf
if_statement ::= IF expression NEWLINE
                 INDENT { statement } OUTDENT
                 { elif_clause }
                 [ else_clause ]

elif_clause ::= IF expression NEWLINE
                INDENT { statement } OUTDENT

else_clause ::= IF expression NEWLINE  /* catches remaining else */
                INDENT { statement } OUTDENT
```

### Loop Statement

```ebnf
loop_statement ::= LOOP expression NEWLINE
                   INDENT { statement } OUTDENT
                | LOOP IDENTIFIER IN expression NEWLINE
                  INDENT { statement } OUTDENT
```

### Match Statement

```ebnf
match_statement ::= MATCH expression NEWLINE
                    INDENT { match_arm } OUTDENT

match_arm ::= MATCH_ARM pattern [ guard ] NEWLINE
              INDENT { statement } OUTDENT

pattern ::= literal_pattern
         | range_pattern
         | wildcard_pattern
         | struct_pattern
         | tuple_pattern
         | binding_pattern

literal_pattern ::= NUMBER | STRING | BOOL_TRUE | BOOL_FALSE

range_pattern ::= expression RANGE_INCL expression
               | expression RANGE_EXCL expression

wildcard_pattern ::= WILDCARD

struct_pattern ::= IDENTIFIER "(" [ pattern_fields ] ")"

pattern_fields ::= pattern_field { "," pattern_field }

pattern_field ::= IDENTIFIER
               | IDENTIFIER ":" pattern

tuple_pattern ::= "(" pattern { "," pattern } ")"

binding_pattern ::= IDENTIFIER

guard ::= GUARD expression
```

---

## Functions

```ebnf
function_def ::= FUNCTION IDENTIFIER "(" [ parameter_list ] ")" 
                 [ "->" type_annotation ] NEWLINE
                 INDENT { statement } OUTDENT

parameter_list ::= parameter { "," parameter }

parameter ::= IDENTIFIER ":" type_annotation
```

---

## Structs

```ebnf
struct_def ::= STRUCT IDENTIFIER "(" [ field_list ] ")"

field_list ::= field { "," field }

field ::= IDENTIFIER ":" type_annotation
```

---

## Borrowing

```ebnf
borrow_block ::= BORROW expression "->" [BORROW_MUT] IDENTIFIER NEWLINE
                 INDENT { statement } OUTDENT
```

---

## Tasks & Channels

### Channel Operations

```ebnf
send_stmt ::= SEND IDENTIFIER "," expression

receive_stmt ::= RECEIVE IDENTIFIER "â†’" IDENTIFIER
```

### Cancel

```ebnf
cancel_stmt ::= CANCEL IDENTIFIER
```

### Spawn

```ebnf
spawn_block ::= SPAWN function_call NEWLINE
                [ INDENT { event_handler } OUTDENT ]

event_handler ::= event_pattern IDENTIFIER NEWLINE
                  INDENT { statement } OUTDENT

event_pattern ::= EVENT_SUCCESS
               | EVENT_ERROR
               | EVENT_PROGRESS
               | EVENT_STOPPED
               | EVENT_REPEAT
```

### Select

```ebnf
select_block ::= SELECT NEWLINE
                 INDENT { select_arm } OUTDENT

select_arm ::= select_operation NEWLINE
               INDENT { statement } OUTDENT

select_operation ::= RECEIVE IDENTIFIER "â†’" IDENTIFIER
                  | SEND IDENTIFIER "," expression
```

---

## Quantum Operations

```ebnf
quantum_block ::= quantum_expr NEWLINE
                  [ INDENT { event_handler } OUTDENT ]

quantum_expr ::= QUANTUM_RACE IDENTIFIER ASSIGN "[" expression_list "]"
              | QUANTUM_COLL IDENTIFIER ASSIGN "[" expression_list "]"
```

---

## Timers

```ebnf
timer_block ::= timer_expr NEWLINE
                INDENT { statement } OUTDENT

timer_expr ::= TIMER_ONCE duration
            | TIMER_REPEAT duration

duration ::= NUMBER time_unit

time_unit ::= "ms" | "s" | "m" | "h"
```

---

## Error Handling

```ebnf
guru_block ::= GURU IDENTIFIER "(" IDENTIFIER ")" NEWLINE
               INDENT { statement } OUTDENT

error_throw ::= ERROR expression
             | WARNING expression
             | FATAL expression
```

---

## Modules & Plugins

```ebnf
module_import ::= MODULE emoji [ AS IDENTIFIER ]

plugin_import ::= PLUGIN IDENTIFIER

module_call ::= MODULE emoji CALL_OP type_annotation "(" [ argument_list ] ")"

plugin_call ::= PLUGIN IDENTIFIER CALL_OP [ type_annotation ] "(" [ argument_list ] ")"

(* FFI *)

ffi_block ::= FFI STRING NEWLINE
              INDENT { ffi_function_decl } OUTDENT

ffi_function_decl ::= FUNCTION IDENTIFIER "(" [ ffi_parameter_list ] ")"
                      [ "->" ffi_type ] NEWLINE

ffi_parameter_list ::= ffi_parameter { "," ffi_parameter }

ffi_parameter ::= IDENTIFIER ":" ffi_type

ffi_type ::= type_annotation
          | pointer_type

pointer_type ::= "*" type_annotation

(* Comments *)

comment_block ::= COMMENT NEWLINE
                  INDENT { any_text } OUTDENT
```

---

## Colors

```ebnf
color_stmt ::= COLOR ":" color_symbol

color_symbol ::= "ğŸ”µ" | "ğŸ”´" | "ğŸŸ¢" | "ğŸŸ¡" | "ğŸŸ£" | "ğŸŸ " 
              | "âšª" | "âš«" | "ğŸŸ¥" | "ğŸŸ©" | "ğŸŸ¦" | "ğŸŸ¨"
              | "â¬œ" | "â¬›"
              | TYPE_LIST IDENTIFIER "[" expression "]"
              | "rgba" "(" NUMBER "," NUMBER "," NUMBER "," NUMBER ")"
```

---

## Memory Management

```ebnf
free_stmt ::= FREE handle
```

---

## Semantic Rules (Non-terminals)

### Type System

```ebnf
(* Type inference rules - not expressible in pure EBNF *)

1. Literal assignment infers type:
   x â† 42           /* x: ğŸ”¢ */
   s â† "hello"      /* s: ğŸ”¤ */

2. First assignment fixes type:
   x â† 42
   x â† "text"       /* ERROR: type mismatch */

3. Operations infer result type:
   x: ğŸ”¢, y: ğŸ”¢ âŸ¹ (x + y): ğŸ”¢
   s: ğŸ”¤, t: ğŸ”¤ âŸ¹ (s + t): ğŸ”¤

4. Functions require explicit return type:
   ğŸ§µ f(x: ğŸ”¢) -> ğŸ”¢
```

### Ownership Rules

```ebnf
(* Move semantics *)

1. Handles are move-only:
   ğŸ’¾f1 â† open("file")
   ğŸ’¾f2 â† f1              /* f1 becomes null_handle */

2. Collections are move-only:
   ğŸ“‹a â† [1, 2, 3]
   ğŸ“‹b â† a                /* a becomes invalid */

3. Primitives are copy-on-assignment:
   x â† 42
   y â† x                  /* x remains valid */

4. Borrowing provides temporary access:
   ğŸ”— collection -> [mut] alias
      /* access via alias */
   /* alias invalid after block */
```

### Scope Rules

```ebnf
1. Block scope:
   Variables live from declaration to end of block (OUTDENT)

2. RAII for handles:
   ğŸ’¾f â† open("file")
   /* ... */
   /* f automatically closed at OUTDENT */

3. Borrow scope:
   ğŸ”— x -> y
      /* y valid only in this block */
   /* y invalid here */
```

### Concurrency Rules

```ebnf
1. Tasks are share-nothing:
   Each task has isolated heap
   
2. Communication via channels only:
   ğŸ“¡ch â† ğŸ›°ï¸(capacity: 0)
   ğŸš€ ch, value
   ğŸ¯ ch â†’ result

3. Quantum operations create parallel tasks:
   ğŸŒ€âš¡ [f1(), f2()]  /* runs in parallel */
   ğŸŒ€ğŸ“¦ [g1(), g2()]  /* runs in parallel */

4. Race determinism:
   If multiple tasks complete simultaneously,
   lowest index wins
```

---

## Precedence Table

Operators in order of precedence (highest to lowest):

```
1. Postfix         . [] ()
2. Unary           ! - (unary)
3. Multiplicative  * / %
4. Additive        + -
5. Range           .. ..<
6. Comparison      < > <= >=
7. Equality        == !=
8. Logical AND     &&
9. Logical OR      ||
10. Assignment     â†
```

---

## Well-formedness Constraints

### Syntactic Constraints

```
1. Indentation must use only TAB characters
2. Each statement on separate line
3. Block statements require INDENT/OUTDENT
4. Matched patterns must be exhaustive or include wildcard
5. Event handlers must handle at least final events
```

### Semantic Constraints

```
1. Variables must be declared before use
2. Types must be consistent with operations
3. Handles cannot be copied, only moved
4. Borrowed values cannot escape their scope
5. Pattern match must be exhaustive
6. Return type must match function signature
7. Channel operations must use channel type
8. Task spawn requires function returning appropriate type
```

---

## Example Derivations

### Simple Assignment

```
statement
  â†’ simple_statement NEWLINE
  â†’ assignment NEWLINE
  â†’ type_annotation IDENTIFIER ASSIGN expression NEWLINE
  â†’ TYPE_NUMBER IDENTIFIER ASSIGN expression NEWLINE
  â†’ TYPE_NUMBER IDENTIFIER ASSIGN primary NEWLINE
  â†’ TYPE_NUMBER IDENTIFIER ASSIGN NUMBER NEWLINE
  â†’ ğŸ”¢ x â† 42 NEWLINE
```

### Match Statement

```
statement
  â†’ compound_statement
  â†’ match_statement
  â†’ MATCH expression NEWLINE INDENT match_arm+ OUTDENT
  â†’ MATCH IDENTIFIER NEWLINE INDENT match_arm match_arm OUTDENT
  â†’ MATCH x NEWLINE INDENT
      MATCH_ARM pattern NEWLINE INDENT statement OUTDENT
      MATCH_ARM wildcard_pattern NEWLINE INDENT statement OUTDENT
    OUTDENT
  â†’ ğŸ”€ x
        âœ 0
            ğŸ’¬ "zero"
        âœ _
            ğŸ’¬ "other"
```

### Quantum Race

```
statement
  â†’ compound_statement
  â†’ quantum_block
  â†’ quantum_expr NEWLINE INDENT event_handler+ OUTDENT
  â†’ QUANTUM_RACE IDENTIFIER ASSIGN "[" expression_list "]" NEWLINE
    INDENT event_handler event_handler OUTDENT
  â†’ ğŸŒ€âš¡ result â† [f1(), f2()]
        â© partial
            ğŸ’¬ partial
        âœ… winner
            ğŸ’¬ winner
```

---

## Notes on Implementation

1. **Lexer**: Must handle grapheme clusters (UAX-29) for emoji tokenization
2. **Parser**: LL(1) or recursive descent recommended
3. **Type Checker**: Requires flow-sensitive analysis for move semantics
4. **Runtime**: Separate heaps per task, channel-based message passing
5. **Optimizer**: Can eliminate unused borrows, inline small functions

---

**End of EBNF Grammar**

This grammar is intended as a formal specification for implementers.
For examples and semantic details, refer to the main Cymple 1.2 specification.
