CYMPLE EBNF Grammar - Version 1.4 (2025-12-04)
================================================

(* Lexical Structure *)

program             = statement_list ;

statement_list      = { statement } ;

statement           = comment
                    | constant_decl
                    | variable_decl
                    | assignment
                    | function_def
                    | struct_def
                    | return_stmt
                    | if_stmt
                    | loop_stmt
                    | match_stmt
                    | output_stmt
                    | input_stmt
                    | borrow_stmt
                    | channel_op
                    | quantum_op
                    | timer_event
                    | error_handler
                    | module_import
                    | ffi_decl
                    | color_cmd
                    | function_call
                    | break_stmt
                    | continue_stmt
                    | stop_stmt
                    ;

(* Comments *)

comment             = "ğŸ“" , [ text ] , NEWLINE
                    | "ğŸ“" , INDENT , text_block , OUTDENT
                    ;

(* Variables and Constants *)

constant_decl       = "ğŸ“˜" , identifier , "â†" , expression ;

variable_decl       = type_prefix , identifier , "â†" , expression ;

assignment          = type_prefix , identifier , "â†" , expression
                    | identifier , "â†" , expression
                    | identifier , "." , identifier , "â†" , expression
                    | identifier , "[" , expression , "]" , "â†" , expression
                    ;

type_prefix         = "ğŸ”¢" | "ğŸ”¤" | "ğŸ“‹" | "ğŸ—ºï¸" | "ğŸ”£" | "ğŸ”˜" | handle_type ;

handle_type         = "ğŸ’¾" | "ğŸµ" | "ğŸ–¼ï¸" | custom_handle ;

(* Functions *)

function_def        = "ğŸ§µ" , identifier , "(" , [ param_list ] , ")" , [ return_type ] , INDENT , statement_list , OUTDENT ;

param_list          = param , { "," , param } ;

param               = identifier , ":" , type_spec ;

return_type         = "->" , type_spec
                    | "->" , "(" , type_spec , { "," , type_spec } , ")"
                    ;

type_spec           = "ğŸ”¢" | "ğŸ”¤" | "ğŸ“‹" | "ğŸ—ºï¸" | "ğŸ”£" | "ğŸ”˜" | "âœ…" | "âœ—" | identifier | handle_type ;

return_stmt         = "â†©" , [ expression ] ;

function_call       = identifier , "(" , [ arg_list ] , ")" ;

arg_list            = expression , { "," , expression } ;

(* Structs *)

struct_def          = "ğŸ§±" , identifier , "(" , field_list , ")" ;

field_list          = field_decl , { "," , field_decl } ;

field_decl          = identifier , ":" , type_spec ;

(* Control Flow *)

if_stmt             = "â“" , condition , INDENT , statement_list , OUTDENT , [ else_stmt ] ;

else_stmt           = "â¤µï¸" , INDENT , statement_list , OUTDENT ;

loop_stmt           = "ğŸ”" , loop_condition , INDENT , statement_list , OUTDENT ;

loop_condition      = expression
                    | identifier , "in" , range_expr
                    | identifier , "=" , range_expr
                    | identifier , "in" , expression
                    | identifier , "=" , expression
                    ;

range_expr          = expression , ".." , expression
                    | expression , "..<" , expression
                    | expression , ".." , expression , "â©" , expression
                    ;

break_stmt          = "break" ;

continue_stmt       = "continue" ;

stop_stmt           = "ğŸ›‘" ;   (* new in 1.4 - explicit stop *)

(* Pattern Matching *)

match_stmt          = "ğŸ”€" , expression , INDENT , match_arms , OUTDENT ;

match_arms          = match_arm , { match_arm } ;

match_arm           = "âœ" , pattern , [ guard ] , INDENT , statement_list , OUTDENT ;

pattern             = literal
                    | identifier
                    | range_expr
                    | "_"
                    | struct_pattern
                    | "(" , pattern , { "," , pattern } , ")"
                    ;

struct_pattern      = identifier , "(" , [ pattern , { "," , pattern } ] , ")" ;

guard               = "â“" , condition ;

(* Expressions *)

expression          = logical_expr ;

logical_expr        = comparison_expr , { ( "&&" | "||" ) , comparison_expr } ;

comparison_expr     = bitwise_expr , [ ( "==" | "!=" | "<" | ">" | "<=" | ">=" ) , bitwise_expr ] ;

bitwise_expr        = additive_expr , { ( "&" | "|" | "^" | "<<" | ">>" ) , additive_expr } ;

additive_expr       = multiplicative_expr , { ( "+" | "-" ) , multiplicative_expr } ;

multiplicative_expr = unary_expr , { ( "*" | "/" | "%" ) , unary_expr } ;

unary_expr          = [ ( "!" | "-" ) ] , primary_expr ;

primary_expr        = literal
                    | identifier
                    | type_prefix , identifier
                    | function_call
                    | input_expr
                    | "(" , expression , ")"
                    | "[" , [ expression_list ] , "]"
                    | "{" , [ map_entries ] , "}"
                    | primary_expr , "." , identifier
                    | primary_expr , "[" , expression , "]"
                    | "null"
                    | "null_handle"
                    ;

expression_list     = expression , { "," , expression } ;

map_entries         = map_entry , { "," , map_entry } ;

map_entry           = string_literal , ":" , expression ;

condition           = expression ;

(* Literals *)

literal             = number_literal
                    | string_literal
                    | bool_literal
                    ;

number_literal      = digit , { digit } , [ "." , digit , { digit } ]
                    | "0x" , hex_digit , { hex_digit }
                    | "0b" , binary_digit , { binary_digit }
                    ;

string_literal      = '"' , { string_char | interpolation } , '"' ;

interpolation       = type_prefix , identifier ;

string_char         = ? any unicode character except '"' ?
                    | escape_sequence
                    ;

escape_sequence     = "\\n" | "\\t" | "\\\"" | "\\\\" | "\\u{" , hex_digit , { hex_digit } , "}" ;

bool_literal        = "âœ…" | "âœ—" ;

(* I/O *)

output_stmt         = "ğŸ’¬" , expression ;

input_stmt          = type_prefix , identifier , "â†" , input_expr ;

input_expr          = "ğŸ”¤ğŸ”½" , string_literal ;

(* Borrowing *)

borrow_stmt         = "ğŸ”—" , identifier , "->" , [ "mut" ] , identifier , INDENT , statement_list , OUTDENT ;

(* Channels *)

channel_op          = channel_create
                    | channel_send
                    | channel_receive
                    ;

channel_create      = "ğŸ“¡" , identifier , "â†" , "ğŸ›°ï¸" , type_spec ;

channel_send        = "ğŸš€" , identifier , "," , expression ;

channel_receive     = type_prefix , identifier , "â†" , "ğŸ¯" , identifier ;

(* Quantum Operations - Enhanced in v1.4 *)

quantum_op          = quantum_race
                    | quantum_collect
                    ;

quantum_race        = "ğŸŒ€âš¡" , type_prefix , identifier , "â†" , "[" , task_list , "]" , INDENT , race_events , OUTDENT ;

quantum_collect     = "ğŸŒ€ğŸ“¦" , "ğŸ“‹" , identifier , "â†" , "[" , task_list , "]" , INDENT , collect_events , OUTDENT ;

task_list           = expression , { "," , expression } ;

(* Race Events - Simplified in v1.4 *)

race_events         = [ timeout_event ] , success_event , [ error_event ] ;

success_event       = "âœ…" , identifier , INDENT , statement_list , OUTDENT ;

error_event         = "âŒ" , identifier , INDENT , statement_list , OUTDENT ;

(* Collect Events - Enhanced in v1.4 *)

collect_events      = [ timeout_event ] , [ progress_event ] , success_event , [ total_failure_event ] ;

progress_event      = "â©" , "ğŸ“‹" , identifier , [ "every" , expression ] , INDENT , statement_list , OUTDENT ;

total_failure_event = "âŒ" , identifier , INDENT , statement_list , OUTDENT ;   (* new in 1.4 *)

(* Timeout - Enhanced in v1.4 *)

timeout_event       = "â±ï¸" , timeout_value , INDENT , statement_list , OUTDENT ;

timeout_value       = number_literal , [ time_unit ]   (* enhanced: optional unit *)
                    | type_prefix , identifier         (* variable (always msec) *)
                    ;

time_unit           = "ms" | "s" | "m" | "h" ;   (* new in 1.4 *)

(* Timers *)

timer_event         = oneshot_timer
                    | periodic_timer
                    ;

oneshot_timer       = "â±ï¸â–¶" , expression , "," , identifier ;

periodic_timer      = "â±ï¸ğŸ”" , expression , "," , identifier ;

(* Error Handling *)

error_handler       = "ğŸ§˜" , identifier , "(" , identifier , ")" , INDENT , statement_list , OUTDENT ;

(* Modules *)

module_import       = internal_module
                    | external_plugin
                    ;

internal_module     = "ğŸ§©" , string_literal ;

external_plugin     = "ğŸ› ï¸" , string_literal ;

(* FFI *)

ffi_decl            = "ğŸ”—" , string_literal , INDENT , ffi_signatures , OUTDENT ;

ffi_signatures      = ffi_signature , { ffi_signature } ;

ffi_signature       = "ğŸ§µ" , identifier , "(" , [ ffi_param_list ] , ")" , [ "->" , ffi_type ] ;

ffi_param_list      = ffi_param , { "," , ffi_param } ;

ffi_param           = identifier , ":" , ffi_type ;

ffi_type            = type_spec
                    | "*" , type_spec   (* pointer type *)
                    ;

(* Colors *)

color_cmd           = "ğŸ¨:" , color_value ;

color_value         = color_emoji
                    | "rgba(" , number_literal , "," , number_literal , "," , number_literal , "," , number_literal , ")"
                    | identifier
                    ;

color_emoji         = "ğŸ”´" | "ğŸŸ " | "ğŸŸ¡" | "ğŸŸ¢" | "ğŸ”µ" | "ğŸŸ£" | "âš«" | "âšª"
                    | "ğŸŸ¥" | "ğŸŸ§" | "ğŸŸ¨" | "ğŸŸ©" | "ğŸŸ¦" | "ğŸŸª" | "â¬›" | "â¬œ"
                    ;

(* Lexical Elements *)

identifier          = letter , { letter | digit | "_" } ;

digit               = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

hex_digit           = digit | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F" ;

binary_digit        = "0" | "1" ;

letter              = ? unicode letter per UAX-31 ? ;

text                = ? any unicode text ? ;

text_block          = { text , NEWLINE } ;

(* Structural Elements *)

INDENT              = ? increase indentation by one TAB ? ;

OUTDENT             = ? decrease indentation by one TAB ? ;

NEWLINE             = ? line break (normalized to \n) ? ;

================================================
SEMANTIC NOTES - Version 1.4
================================================

1. QUANTUM OPERATIONS SEMANTICS

Race (ğŸŒ€âš¡):
- Starts all tasks in parallel
- Returns first successful result
- Automatically sends ğŸ›‘ to remaining tasks
- Deterministic: Lowest index wins on simultaneous completion
- Without timeout handler: Throws âŒ "Timeout" automatically
- No progress events (removed in v1.4)

Collect (ğŸŒ€ğŸ“¦):
- Starts all tasks in parallel
- âœ… fires when at least one task succeeds
- Failed tasks included in results (use filter_ok/filter_error)
- ğŸ›‘ in â© block stops all running tasks
- âŒ total_failure only fires if ALL tasks fail
- Without timeout handler: Returns partial results

2. TIMEOUT BEHAVIOR (Enhanced v1.4)

Time Units:
- ms  = milliseconds
- s   = seconds
- m   = minutes
- h   = hours
- none = milliseconds (default)

Variables:
- Always interpreted as milliseconds
- Example: ğŸ”¢t â† 3000 means 3000ms

Conversion:
- 1s  = 1000ms
- 1m  = 60000ms
- 1h  = 3600000ms

3. PROGRESS FREQUENCY (New v1.4)

Syntax: â© ğŸ“‹partial every N

- N = literal number: Fire every N completed tasks
- N = variable: Fire every variable number of tasks
- No "every": Fire after each task (v1.3 behavior)

Performance:
- Large N reduces event overhead
- Recommended for >100 tasks: every 10 or higher

4. STOP SIGNAL (ğŸ›‘) - Unified v1.4

Quantum Operations:
- In â© block: Stops all running tasks
- Keeps completed results
- Returns immediately

Channels:
- Closes channel
- Signals to receiver

Loops:
- Breaks out of loop
- Equivalent to "break"

Tasks:
- Checks â“ ğŸ›‘ to detect cancellation
- Allows graceful shutdown

5. ERROR HANDLING

Manual Filtering:
- filter_ok(ğŸ“‹results) â†’ successful tasks
- filter_error(ğŸ“‹results) â†’ failed tasks

Result Properties:
- result.is_ok â†’ boolean
- result.value â†’ success value
- result.error â†’ error value

Total Failure:
- Only fires if results.length == 0
- All tasks must fail completely
- Use for fallback logic

6. OPERATOR PRECEDENCE

Highest to Lowest:
1. Primary (., [], (), function calls)
2. Unary (!, -)
3. Multiplicative (*, /, %)
4. Additive (+, -)
5. Bitwise shifts (<<, >>)
6. Bitwise (&, |, ^)
7. Comparison (==, !=, <, >, <=, >=)
8. Logical (&&, ||)
9. Assignment (â†)

7. TYPE SYSTEM

All types nullable:
- Use "null" for checking
- Handles: "null_handle"

Move semantics:
- Collections: ğŸ“‹, ğŸ—ºï¸, ğŸ”£
- Handles: ğŸ’¾, ğŸµ, ğŸ–¼ï¸, etc.
- After move: original = null/null_handle

Borrowing:
- Block-scoped only
- Cannot return borrowed values
- Cannot send via channels

8. SCOPING RULES

Global:
- Top-level constants (ğŸ“˜)
- Top-level functions (ğŸ§µ)

Function:
- Parameters
- Local variables
- Local constants

Block:
- Loop variables
- If/else variables
- Borrow aliases

9. ENCODING & NORMALIZATION

- UTF-8 encoding required
- NFC normalization before tokenization
- TAB (U+0009) for indentation only
- Line endings normalized to \n

10. RESERVED SYMBOLS (v1.4)

Cannot be redefined:
- All emoji type prefixes (ğŸ”¢, ğŸ”¤, etc.)
- Control flow (â“, â¤µï¸, ğŸ”, ğŸ”€, âœ)
- Operators (â†, â†©, ğŸ›‘)
- Quantum (ğŸŒ€âš¡, ğŸŒ€ğŸ“¦)
- Events (âœ…, âŒ, â©, â±ï¸)
- Channels (ğŸ“¡, ğŸ›°ï¸, ğŸš€, ğŸ¯)
- Special (ğŸ§˜, ğŸ”—, ğŸ—‘ï¸, ğŸ“, ğŸ“˜)

================================================
EXAMPLE DERIVATIONS - Version 1.4
================================================

Example 1: Quantum Race with Timeout (v1.4)
--------------------------------------------
quantum_race
â†’ "ğŸŒ€âš¡" type_prefix identifier "â†" "[" task_list "]" INDENT race_events OUTDENT
â†’ "ğŸŒ€âš¡" "ğŸ”¤" "result" "â†" "[" expression "," expression "]" INDENT timeout_event success_event OUTDENT
â†’ "ğŸŒ€âš¡" "ğŸ”¤" "result" "â†" "[" function_call "," function_call "]" INDENT "â±ï¸" timeout_value INDENT statement_list OUTDENT "âœ…" identifier INDENT statement_list OUTDENT OUTDENT
â†’ "ğŸŒ€âš¡ ğŸ”¤result â† [fetch_eu(), fetch_us()]
      â±ï¸ 3s
          ğŸ’¬ \"Timeout\"
      âœ… ğŸ”¤winner
          â†© ğŸ”¤winner"

Example 2: Quantum Collect with Progress (v1.4)
------------------------------------------------
quantum_collect
â†’ "ğŸŒ€ğŸ“¦" "ğŸ“‹" identifier "â†" "[" task_list "]" INDENT collect_events OUTDENT
â†’ "ğŸŒ€ğŸ“¦" "ğŸ“‹" "results" "â†" "[" expression "," expression "]" INDENT progress_event success_event OUTDENT
â†’ "ğŸŒ€ğŸ“¦" "ğŸ“‹" "results" "â†" "[" function_call "," function_call "]" INDENT "â©" "ğŸ“‹" identifier "every" expression INDENT statement_list OUTDENT "âœ…" "ğŸ“‹" identifier INDENT statement_list OUTDENT OUTDENT
â†’ "ğŸŒ€ğŸ“¦ ğŸ“‹results â† [task1(), task2()]
      â© ğŸ“‹partial every 10
          ğŸ’¬ \"Progress\"
          â“ condition
              ğŸ›‘
      âœ… ğŸ“‹all
          â†© ğŸ“‹all"

Example 3: Total Failure Event (New v1.4)
------------------------------------------
total_failure_event
â†’ "âŒ" identifier INDENT statement_list OUTDENT
â†’ "âŒ" "ğŸ”¤" "total_failure" INDENT output_stmt return_stmt OUTDENT
â†’ "âŒ ğŸ”¤total_failure
      ğŸ’¬ \"All failed\"
      â†© false"

================================================
End of EBNF Grammar - Cymple 1.4
================================================
