CYMPLE EBNF Grammar - Version 1.3 (2025-12-02)
================================================

(* Lexical Structure *)

program             = statement_list ;

statement_list      = { statement } ;

statement           = comment
                    | constant_decl
                    | variable_decl
                    | assignment
                    | function_def
                    | struct_def
                    | return_stmt
                    | if_stmt
                    | loop_stmt
                    | match_stmt
                    | output_stmt
                    | input_stmt
                    | borrow_stmt
                    | channel_op
                    | quantum_op
                    | timer_event
                    | error_handler
                    | module_import
                    | ffi_decl
                    | color_cmd
                    | function_call
                    | break_stmt
                    | continue_stmt
                    ;

(* Comments *)

comment             = "ğŸ“" , [ text ] , NEWLINE
                    | "ğŸ“" , INDENT , text_block , OUTDENT
                    ;

(* Variables and Constants *)

constant_decl       = "ğŸ“˜" , identifier , "â†" , expression ;

variable_decl       = type_prefix , identifier , "â†" , expression ;

assignment          = type_prefix , identifier , "â†" , expression
                    | identifier , "â†" , expression
                    | identifier , "." , identifier , "â†" , expression
                    | identifier , "[" , expression , "]" , "â†" , expression
                    ;

type_prefix         = "ğŸ”¢" | "ğŸ”¤" | "ğŸ“‹" | "ğŸ—ºï¸" | "ğŸ”£" | handle_type ;

handle_type         = "ğŸ’¾" | "ğŸµ" | "ğŸ–¼ï¸" | custom_handle ;

(* Functions *)

function_def        = "ğŸ§µ" , identifier , "(" , [ param_list ] , ")" , [ return_type ] , INDENT , statement_list , OUTDENT ;

param_list          = param , { "," , param } ;

param               = identifier , ":" , type_spec ;

return_type         = "->" , type_spec
                    | "->" , "(" , type_spec , { "," , type_spec } , ")"
                    ;

type_spec           = "ğŸ”¢" | "ğŸ”¤" | "ğŸ“‹" | "ğŸ—ºï¸" | "ğŸ”£" | "âœ…" | "âœ—" | identifier | handle_type ;

return_stmt         = "â†©" , [ expression ] ;

function_call       = identifier , "(" , [ arg_list ] , ")" ;

arg_list            = expression , { "," , expression } ;

(* Structs *)

struct_def          = "ğŸ§±" , identifier , "(" , field_list , ")" ;

field_list          = field_decl , { "," , field_decl } ;

field_decl          = identifier , ":" , type_spec ;

(* Control Flow *)

if_stmt             = "â“" , condition , INDENT , statement_list , OUTDENT , [ else_stmt ] ;

else_stmt           = "â¤µï¸" , INDENT , statement_list , OUTDENT ;   (* new in 1.3 *)

loop_stmt           = "ğŸ”" , loop_condition , INDENT , statement_list , OUTDENT ;

loop_condition      = expression
                    | identifier , "in" , range_expr
                    | identifier , "=" , range_expr        (* new in 1.3 - alternative syntax *)
                    | identifier , "in" , expression
                    | identifier , "=" , expression        (* new in 1.3 - alternative syntax *)
                    ;

range_expr          = expression , ".." , expression
                    | expression , "..<" , expression
                    | expression , ".." , expression , "â©" , expression
                    ;

break_stmt          = "break" ;

continue_stmt       = "continue" ;

(* Pattern Matching *)

match_stmt          = "ğŸ”€" , expression , INDENT , match_arms , OUTDENT ;

match_arms          = match_arm , { match_arm } ;

match_arm           = "âœ" , pattern , [ guard ] , INDENT , statement_list , OUTDENT ;

pattern             = literal
                    | identifier
                    | range_expr
                    | "_"
                    | struct_pattern
                    | "(" , pattern , { "," , pattern } , ")"
                    ;

struct_pattern      = identifier , "(" , [ pattern , { "," , pattern } ] , ")" ;

guard               = "â“" , condition ;

(* Expressions *)

expression          = logical_expr ;

logical_expr        = comparison_expr , { ( "&&" | "||" ) , comparison_expr } ;

comparison_expr     = bitwise_expr , [ ( "==" | "!=" | "<" | ">" | "<=" | ">=" ) , bitwise_expr ] ;

bitwise_expr        = additive_expr , { ( "&" | "|" | "^" | "<<" | ">>" ) , additive_expr } ;

additive_expr       = multiplicative_expr , { ( "+" | "-" ) , multiplicative_expr } ;

multiplicative_expr = unary_expr , { ( "*" | "/" | "%" ) , unary_expr } ;

unary_expr          = [ ( "!" | "-" ) ] , primary_expr ;

primary_expr        = literal
                    | identifier
                    | type_prefix , identifier                (* variable reference with type *)
                    | function_call
                    | input_expr
                    | "(" , expression , ")"
                    | "[" , [ expression_list ] , "]"        (* list literal *)
                    | "{" , [ map_entries ] , "}"            (* map literal *)
                    | primary_expr , "." , identifier         (* property access *)
                    | primary_expr , "[" , expression , "]"   (* indexing *)
                    | "null"
                    | "null_handle"
                    ;

expression_list     = expression , { "," , expression } ;

map_entries         = map_entry , { "," , map_entry } ;

map_entry           = string_literal , ":" , expression ;

condition           = expression ;

(* Literals *)

literal             = number_literal
                    | string_literal
                    | bool_literal
                    ;

number_literal      = digit , { digit } , [ "." , digit , { digit } ]
                    | "0x" , hex_digit , { hex_digit }
                    ;

string_literal      = '"' , { string_char | interpolation } , '"' ;   (* enhanced in 1.3 *)

interpolation       = type_prefix , identifier ;                       (* new in 1.3 *)

string_char         = ? any unicode character except '"' ?
                    | escape_sequence
                    ;

escape_sequence     = "\\n" | "\\t" | "\\\"" | "\\\\" | "\\u{" , hex_digit , { hex_digit } , "}" ;

bool_literal        = "âœ…" | "âœ—" ;

(* I/O *)

output_stmt         = "ğŸ’¬" , expression ;

input_stmt          = type_prefix , identifier , "â†" , input_expr ;

input_expr          = "ğŸ”¤ğŸ”½" , string_literal ;

(* Borrowing *)

borrow_stmt         = "ğŸ”—" , identifier , "->" , [ "mut" ] , identifier , INDENT , statement_list , OUTDENT ;

(* Channels and Tasks *)

channel_op          = channel_create
                    | channel_send
                    | channel_receive
                    | task_spawn
                    | task_cancel
                    | channel_select
                    ;

channel_create      = "ğŸ“¡" , identifier , "â†" , "ğŸ›°ï¸" , "(" , "capacity:" , expression , ")" ;

channel_send        = "ğŸš€" , identifier , "," , expression ;

channel_receive     = "ğŸ¯" , identifier , "â†’" , identifier ;

task_spawn          = "spawn" , function_call , [ event_handlers ] ;

task_cancel         = "ğŸ›‘" , identifier ;

channel_select      = "select" , INDENT , select_arms , OUTDENT ;

select_arms         = select_arm , { select_arm } ;

select_arm          = ( channel_send | channel_receive ) , INDENT , statement_list , OUTDENT ;

event_handlers      = INDENT , event_handler , { event_handler } , OUTDENT ;

event_handler       = event_symbol , identifier , INDENT , statement_list , OUTDENT ;

event_symbol        = "âœ…" | "âŒ" | "â©" | "â¹ï¸" ;

(* Quantum Operations *)

quantum_op          = quantum_race | quantum_collect ;

quantum_race        = "ğŸŒ€âš¡" , identifier , "â†" , "[" , expression_list , "]" , [ event_handlers ] ;

quantum_collect     = "ğŸŒ€ğŸ“¦" , identifier , "â†" , "[" , expression_list , "]" , [ event_handlers ] ;

(* Timers *)

timer_event         = oneshot_timer | periodic_timer ;

oneshot_timer       = "â±ï¸â–¶" , duration , INDENT , statement_list , OUTDENT ;

periodic_timer      = "â±ï¸ğŸ”" , duration , INDENT , statement_list , OUTDENT ;

duration            = number_literal , time_unit ;

time_unit           = "ms" | "s" | "m" | "h" ;

(* Error Handling *)

error_handler       = "ğŸ§˜" , identifier , "(" , identifier , ")" , INDENT , match_stmt , OUTDENT ;

(* Modules *)

module_import       = "ğŸ§©" , module_name , [ "as" , identifier ]
                    | "ğŸ› ï¸" , plugin_name
                    ;

module_name         = emoji_identifier ;

plugin_name         = identifier ;

module_call         = "ğŸ§©" , module_name , "â–¶" , [ type_spec ] , "(" , [ arg_list ] , ")"
                    | "ğŸ› ï¸" , plugin_name , "â–¶" , [ type_spec ] , "(" , [ arg_list ] , ")"
                    ;

(* FFI *)

ffi_decl            = "ğŸ”—" , string_literal , INDENT , ffi_functions , OUTDENT ;

ffi_functions       = ffi_function , { ffi_function } ;

ffi_function        = "ğŸ§µ" , identifier , "(" , [ ffi_param_list ] , ")" , [ "->" , ffi_type ] ;

ffi_param_list      = ffi_param , { "," , ffi_param } ;

ffi_param           = identifier , ":" , ffi_type ;

ffi_type            = type_spec | pointer_type ;

pointer_type        = "*" , type_spec ;

(* Colors *)

color_cmd           = "ğŸ¨:" , color_value ;

color_value         = color_emoji
                    | "rgba(" , expression , "," , expression , "," , expression , "," , expression , ")"
                    | identifier , "[" , expression , "]"
                    ;

color_emoji         = "ğŸ”´" | "ğŸŸ¢" | "ğŸ”µ" | "ğŸŸ¡" | "ğŸŸ£" | "ğŸŸ¤" | "âšª" | "âš«"
                    | "ğŸŸ¥" | "ğŸŸ©" | "ğŸŸ¦" | "ğŸŸ¨" | "ğŸŸª" | "ğŸŸ«" | "â¬œ" | "â¬›"
                    ;

(* Identifiers and Terminals *)

identifier          = letter , { letter | digit | "_" } ;

emoji_identifier    = emoji , { emoji } ;

letter              = "a" .. "z" | "A" .. "Z" ;

digit               = "0" .. "9" ;

hex_digit           = digit | "a" .. "f" | "A" .. "F" ;

emoji               = ? any Unicode emoji character ? ;

(* Whitespace and Structure *)

INDENT              = ? increase indentation level by one TAB ? ;

OUTDENT             = ? decrease indentation level by one TAB ? ;

NEWLINE             = "\n" ;

text                = { ? any character except NEWLINE ? } ;

text_block          = { text , NEWLINE } ;

(* Notes on Version 1.3 Changes *)

(*
1. String interpolation: string_literal now includes interpolation production
2. Else symbol: else_stmt uses â¤µï¸ instead of âŒ
3. Property access: primary_expr includes .length and .size access
4. Alternative range syntax: loop_condition includes '=' as alternative to 'in'
5. Optional return type: function_def has optional return_type
6. Comparison operator: Only '==' for equality (not '=')
7. Logical vs bitwise: && || for logical, & | ^ for bitwise
*)

(* End of Grammar *)
